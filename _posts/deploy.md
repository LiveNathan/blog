I want your help to write a blog post. In the previous blog post I had talked about how coming up this fall I will be
going back to working on some shows as a live sound engineer and how I was not super enthusiastic about that and how the
project I had been working on for the first half of this year had kind of not hit a dead end but I had just run into
some challenges and was kind of losing motivation for it so I decided to take some time to try working on some new stuff
and I thought what might be fun to do is something that I was going to do with my work. I was working more in the micro
SAS vein and against better business guidance I decided to try some things again for live sound engineers aka for
myself. So the TLDR of everything I just said is that I thought it might be it might make this work that I have to do
coming up as a live sound engineer more fun if I was also working on a software product that would help me do some of
that work. So maybe some automation or something. A year ago I really tried to double down on B2B SAS or micro SAS. I
interviewed lots of commercial AV integrator managers but wasn't really able to get a product off the ground or make any
sales. One thing that made that product difficult to get started with is that I've never really been an AV manager. Back
when I lived in the Bay Area I was technically a project manager for maybe three or four months before American
Audiovisual Center got bought by PSAV now called Encore. And that essentially made my position redundant and so I got
fired or laid off I guess is the correct term. Anyway so technically I have been a project manager but I didn't really
do much of any management when I was in that position. They just had me in that position so that they could put me on
shows anytime they wanted to. For some reason it was just easier to give me that title for some reason. I don't know why
they did things that way but no one ever taught me anything about management and I didn't actually manage any shows.
That all is to say that I don't actually have much experience or I've never been in the shoes of a commercial AV
integrator manager. These people that I was trying to sell stuff to. Now that's not necessarily a problem. It's just
that I couldn't I didn't have enough confidence that I could just build a product with my own knowledge right off the
bat. And so I really needed someone to partner with me. Now one way I could have handled that is to try to get a job at
a commercial AV integrator. And then do that job for a while maybe I don't know three six months a year a couple years.
And then come back and build the product. And then I would have confidence that I knew what I was doing based on you
know real life experience. But I didn't want to do that. I wanted someone to partner with me and basically invest in the
product. Become an early adopter and then kind of guide me and give me their feature requests and stuff. So that's all
to say that now you know build going on this path of building stuff for myself again is also kind of fun and
self-serving. Because it's just easier like I know it's for me. I'm one of the customers and so I just kind of know what
to do. I kind of see all the path in front of me and I know kind of the choices that need to be made. And so then
everything else is just kind of a technical challenge. Like how do I actually technically get this feature done that I
know that needs to be done or get this design done the way I know it needs to be done. So I just started thinking about
oh so I was talking about why it's I guess risky from a business perspective. B2B is a lot safer are less risky and SAS
is less risky. I used to think that selling to live sound engineer was kind of B2B but not really it's really B2C. They
live sound engineers have pretty much the same or similar behaviors as consumers. You could potentially it is
technically what I'm making a professional tool for technical things. But typically when you say something like that it
doesn't mean that you can give it like enterprise level pricing but it typically the price is higher. But I have found
just over the years that live sound engineers are very sensitive to pricing unless it's something that really takes off
and becomes like really in style. And then you can sell your software for more or you know the just the perception of it
is different. Anyway all of that is to say that what I'm doing doesn't make a lot of business sense from everything that
I've learned. And the books that I've read and the guidance that I've received. But I just thought it would be more fun
and I was kind of out of ideas. So I said what can I do that would be fun and I could actually use and then I could go
back to sort of talking about it with my own audience of live sound engineers. And so I was just looking at the things
that I have to do to prepare for a show that I don't like to do. One of them is console setup. Mixing console setup. Not
super interesting for me. I've done it you know a thousand times at this point. I kind of do it the same every time. And
so and you know most of what I do for pre-production work for shows is unpaid. Now I realized that I should if I were
more responsible in my business as a independent contractor freelance live sound engineer that I would renegotiate and
get that paid. Right. And I've never tried to do that and I don't know really how to do that. I don't want to have to
think about it. I don't really care that much about my business as a freelance sound engineer anymore. I know people do
it. A lot of people don't do it though. I think what most people do like me is just try to minimize the amount of
pre-production work they have to do. And then they just try to make sure or at least what I try to do is just try to
make sure that my day rate is high enough that any small amount of pre-production work that I have to do here or there
just kind of equals out. I only ever worked for one company and that was got milk in the Bay Area that paid for
pre-production work. So they would actually have pre-production meetings for almost every show, even kind of small ones.
And so I would have to drive into their office in San Francisco just for like a usually like 30 minute meeting,
honestly, and they would pay you for an hour of being there. And it was kind of funny, but I appreciated it. I thought
it was pretty cool. I work on, I work for companies that do big, um, VIP shows for very important clients like the White
House who never have pre-production meetings and don't even want to meet with me. And they're just too busy. And they're
just too busy. They'll just, you know, text you a few photos or, you know, they, they have a, they have, they send you
materials, but they just don't have pre-production meetings. And to me, that's wild. So it's not typically a thing
people do. They just let you handle it however you want. And then I guess they just hope that you show up prepared
anyway. I don't know. I don't know what AV companies are thinking and why they do or don't do that. That's not true.
I've worked for a couple of other companies that will, on some shows, have a meeting where you'll meet on Zoom and just
go through some of the materials. But Got Milk was definitely the only company that I worked for that, that was paid and
they wanted you to be there in person. And they just kind of did that for every show. So, all of that is to say that one
of the reasons that I don't like the pre-production work that I do, including mixing console setup, is that it's unpaid.
And it's just sort of tedious and takes a long time. It's just sort of like clicking a lot of buttons and going through
a lot of settings. So I've done it many times and it's fine. You just sort of like relax and sit down and it takes an
hour or so. I guess another thing that I don't like about it, though, is that you're not really building off of the
things you're learning. You're doing like so much sort of tedious, just sort of mind numbing little detail work that
there's not a lot of time for like interesting changes or growth or creativity. Like, oh, how could I potentially handle
this differently this time? And it's just like, OK, I've got a thousand buttons to click here. So how can I do that as
quickly as possible? What a lot of career sound engineers do and what I used to do more in the past is to work from a
set of templates. And that'll help you get started a lot faster. And channel presets. So you can have a template saved
for a particular console brand and model. You could open that up. You can also have just a preset for a particular
component, like just the EQ of a channel or maybe for an entire channel. And every console manufacturer kind of handles
that differently. So eventually I abandoned that using any of that stuff. One, because I just kind of got lazy. You have
to kind of maintain them and keep them up to date with how your preferences change. So for example, let's say that I
create a template and I turn all of the high pass filters on on every channel. And I set them all at a particular
frequency. And then a couple of months later, my preferences change and I decide that I want them all at a different
frequency. So now the template is less valuable because I got to open it up and change every frequency. What I should
really do is go back to that template, change every frequency, save it again. And so there's that kind of maintenance
thing going on. And you need to kind of make some time for that and be diligent about that. And the other thing is that
there are just too many console brands and manufacturers. So if I work with maybe six or eight different consoles
throughout the year, it's actually probably more. It's probably, you know, eight to 12 a year. Then I need templates and
presets for every different combination of manufacturer and model. And as, you know, sort of styles, what's in fashion
changes and AV companies get new consoles. Then I just sort of lost interest and enthusiasm for maintaining that stuff.
Because then it's like, okay, I used to have some templates for the Yamaha CL5. Okay, well, now everyone has the DM7.
Okay, so now I need to learn the DM7 and then translate those and then create new presets. And I just didn't want to do
that. So all of that is to say that I don't really like this kind of pre-production work. And, you know, console setup
to me seems kind of tedious and uninteresting. I would like to just open it up already done and then see if there are
any like minor changes I need to make. Oh, and the reason that most people like me don't like to work from a previous
show file where everything is already done is just really the fear that maybe there's some minor change in there and you
don't remember where it is. So one of the reasons that people like me like to create every console file from scratch is
so that we know where everything is. That's also why it's really hard to work from somebody else's show file. Because if
you just open it up and start working from it, then if you need to make a change, you don't always know where it is. You
know, how are things routed? How are they handling the EQ and the outputs, etc.? There might be, you know, in modern
digital consoles, there are just so many layers and different parameters. It's really hard to sometimes know where to go
to change something unless you just created it from the ground up and you remember what that architecture is. It's
interesting to kind of compare it to software, different software architectures. So for example, in software, if you're
using hexagonal architecture or ports and adapters architecture, I think it's also called, you can kind of open up any
project in that architecture and at least know how it's laid out and where the files are because it's just a folder
structure, essentially. I don't think we have that kind of stuff codified in live sound. Everyone just, it's just kind
of the wild, wild west. You know, everyone just kind of does their own thing, sets up their console how they like it
because you don't really need anyone else to understand it. You don't work on a console in a team of people, you know,
where you might have like 100 software developers working on a code base across an organization. You only ever have
typically one sound engineer who needs to understand something. And that's not true on bigger shows. I'm just talking
about like most, a lot of live shows where there is a single operator on a single console. They just set it up to their
preferences. So it's, that's why it's difficult to use someone else's console setup. And that's why most people tend to
just set it up from scratch because they might not even remember how they set it up previously if they start from that
old show file. So there are lots of other things that just take a lot of time to do during the pre-production work on
the audio for a show. But that was just one of the first ones that I thought of. It's one of the first ones that I have
on my list of things to prepare for a show. So I decided to just tackle it. And I made this 30 second video called What
If You Could Chat With Your Console where I just demonstrated a simple chat app where you could type or dictate into a
chat dialogue a few commands for the console setup. And then it, you can see in the console that it's doing them for
you. And I shared that around a few places. And a few people seemed interested. And of course, everybody has an opinion
about AI these days. So probably a third of people just complained about it and hated it. And about a third of people
thought it was a cool idea. And about a third of people just had questions. One of the biggest surprises of that process
on the technical side is that I built the first version as a single web app. And I deployed it to my server. And then I
went to use it for the first time. And it didn't work at all. It did nothing. And I'm so kind of naive on some of these
topics that I didn't even realize that, of course, it was working great running locally on my machine because it has
access to the internet and it has access to everything on my local network. But once I deployed it to the cloud, now
it's in a completely different location. It only has access to that stuff. It doesn't know anything about my local
network. And in fact, there are security things like, I can't remember, it's CORS, C-O-R-S, something like cross-origin,
something security. There are security things in place in browsers that make it impossible for, or typically impossible
unless you do something about it, make it impossible for some kind of web application running in a server somewhere to
make any calls to your local network or interact with anything there. And that's typically probably for the best.
Anyway, that was a big surprise. And after some research, I decided that the best path forward was to split the
application into a server client architecture. And then all of a sudden, the next thing I had to do was learn how to
package and distribute desktop applications. It's something I never wanted to have to learn about. And it was painful.
And I still don't really understand it. But actually, my idea for this blog post was more of a technical blog post where
I would just share some of the things that I learned. Because I thought it would take me like a day. And it ended up
taking a full week just because I tried so many things that seemed like they would work and then didn't work. So I had
heard about this project called JDeploy. And I listened to a podcast with the creator and it seemed like a good way to
go. So on one Sunday, I got into that and I spent about five hours getting it set up and building a GitHub workflow and
everything only to discover that it didn't work. Now, I blame Claude for what happened next, unfortunately, because it
wasn't working and I didn't really know how to debug it because when it gets packaged into an app, you start it and
there's no terminal or console or logs or anything to see. Or at least, you know, I'm such a novice. I don't really know
how to access them yet. And it didn't seem like it was working. So I asked Claude to research the problem for me and it
told me that JDeploy is not compatible with Java 24. So I got frustrated with it and gave up on it. Now, looking back, I
realized that's not true. And I found out since then that JDeploy is compatible with Java 24. But, oh, and there's a way
to view console logs even after it's been packaged into an app. And I've been using that for debugging since then. But
at that time, I didn't know that. So, you know, I just got an answer. I thought, okay, it doesn't work. Fine, fuck it.
I'll move on to something else. After that, I thought, okay, Growl VM, native images, that's the way to go. I've used it
before. I know how to make it work. This project will work with that. So then I set up a whole, I spent like a whole
other five hours setting up another GitHub workflow that would deploy to Growl VM native image. And I should tell you
that I'm not just jumping straight into GitHub workflows. I'm always trying things locally. And when I run the app
locally, I see that I double click on it. It opens a terminal and then runs the app. And in that moment, I'm thinking,
yeah, but after I do this GitHub workflow and distribute it, it's not going to do that. I don't know why, but that's
totally what I thought. I thought that it wasn't going to show those windows. So then I set up that whole GitHub
workflow. I deploy it. I download the first version of it from GitHub after I've deployed the release. And I run it. And
of course, the first thing it does is open a terminal window and run the app. And I think, okay, it's cool that it's
working, but it's really not cool that it opens this terminal window. So number one, it just doesn't look very
professional. And number two, it exposes all of the implementation details. So you see how everything is working. And
then, I don't know, maybe you can interact with it and hack it and get my keys out, my API keys and stuff. And I don't
know what, but just, yeah, it doesn't look good. So what I learned is that I don't think that's what GraalVM native
images are for. I thought maybe it was something that you could use to distribute. And I guess you can, but there's no
way on Mac to run it without the console opening. I don't know if console and terminal are the same thing. There is a
way in Windows, for some reason, you can add a flag to the compilation when you make the native image and it will
suppress the console, but not on Mac for some reason. So that felt like some more time wasted. I did some more research
and found out about this other project called Tauri. I don't know how you pronounce it. Tauri, spelled T-A-U-R-I. So I
worked on that for about two days because that seemed really promising. And it actually looked pretty cool. It has a
rust back end, which I don't know anything about, but I got Claude to help me with that. And I got farther with that
than anything else. I could see right away that, you know, once it got packaged up, you could double click on it and it
would immediately open a window. And it's cool that it's a little bit like Electron to my understanding. I've never used
Electron, but my understanding is that Electron packages an entire Chromium browser into the app. And this does the same
thing, but it uses something a little bit more lightweight called WebKit so that the artifact in the end is smaller. So
I was liking that. It looked like a real app, you know, so instead of just opening a window in your default browser, it
opens as an app and you can close it and open it. I don't know, just look more like a real app, which was nice. In
addition, it seemed like there was a better future to using Tari because you can package it to all different locations.
You can supposedly pack, it can go to, you know, iOS and Android and all these different places. And I was thinking,
great, I like this a lot. So again, I set up a whole GitHub workflow and the reason that I mention that every time is
that that always takes an hour or two to debug because you push it to GitHub and then you got to wait for like 30
minutes for it to finish everything. So I spent two days on that, finally got to a place where it was deploying, it was
working great. I thought I was almost done and I went to test it on my Windows machine and it wouldn't run. It was just
a blank screen. And that's when I was shocked to discover that it does not package the Java runtime environment and you
need that in any Java app. So if you've ever used Rumiku Wizard, for example, one of the first things that that
installer does is to install Java on your machine and there are other Java apps that do that as well. Like the, I think
the older version of MapXT. Anyway, I'm such a novice. I don't understand any of this because I'm so used to that just
kind of all being handled by Docker when you deploy web applications to the cloud, to a server. But of course you need
Java to run a Java app. And then I was just so frustrated again because I was like, fuck, how am I ever going to figure
this out? So my next option were that I could have just packaged, figured out a way to package Java with Tauri. But
Tauri is not necessarily built for Java apps. And so I was thinking about what to do next and that's when I learned
about Conveyor. So Conveyor is another product like Tauri, like Electron that takes your app and packages it into, you
know, something to go to many other platforms. But this is the first one that I looked at that is a third-party paid
application. In the end, I ended up being a lot more, having a lot more success in the end with Conveyor because it is
designed to support Java apps and not necessarily VODen apps. So I still had to do some work to figure out how to make
VODen work like a desktop app, which essentially involves forcing it to open a browser window and then to shut down when
that browser window closes. And so I think if I had more experience and knew what I was doing, then I would have started
this whole project trying to learn something like Java effects or Swing or something that's really designed for desktop
apps. And when you first start with Conveyor, it has like some starters for Java effects, for example. Anyway, I'm
trying, you know, I'm doing sort of non-traditional things and lots of workarounds and lots of dead ends and false
starts because I've never done this kind of stuff before. But now I get to share all this stuff with you, the reader. So
what I ended up making was a proof of concept application with VODen and Conveyor and building a GitHub workflow. And so
I'll add a link to that. One of the pleasant surprises with Conveyor is, well, I should say, first of all, one of the
things that's the hardest things about it is the configuration file that it uses. It uses some special configuration.
Anyway, it looks like JSON but is not really, I think, or is something in addition to JSON. Anyway, my IDE, IntelliJ,
does not really understand it. And so there's no code completion, really. And it doesn't tell you when you're typing
anything wrong. Anyway, so that was difficult to get around and there was no way. I just had to, there's just a lot of
documentation to read and I had to get a lot of help from Claude. Anyway, it's, good thing is that it's well documented.
The documentation is pretty good. And it's surprisingly fast. Like the other options that I was using, you know, to
package, to create a GrauVM native image takes like, I don't know, just running it on my local machine. It might take
five minutes. But to package this app with conveyor, it might take less than 30 seconds. And the other big surprise is
that the artifacts are actually smaller. So I'll have to double check this now on my machine because I'm not sure if I
ran a full one. But I think the GrauVM native image that I made was like 180 megabytes. And the app that I made with
this proof of concept for conveyor was 130 megabytes. So I don't know what conveyor is doing. It's doing its own kind of
like compression and restructuring. But it's faster than GrauVM native images and the artifact is smaller. So that's
pretty cool. Another nice benefit is that it makes a nice little download page for you or it can if you set it to
directly into GitHub pages and then you can, you know, connect GitHub pages. Then you have a nice little download page
that auto detects what processor you're on or operating system and tries to give you the correct download link. So the
story is getting kind of long, but mainly what I wanted to share is all of the technologies that I tried and that ended
up not working for my first time creating a Java desktop app and trying to use Vauden, which is the technology I've just
been using for the last year and a half or so. And man, it was a struggle, but it seems like conveyor is going to work.
Um, I'm not super psyched that it's a paid tool because it goes from
like $0 a month for, you know, free or, um, open source projects to $45 a month for, um, commercial products. And my
product, you know, currently only has one customer and is, uh, just not earning very much money yet to justify that. So
I'll have to figure that out. Um, but I'm happy that, you know, people like the creators of conveyor are out there
trying to help people like me do things with Java. And I guess I should end this post on a positive note, which is that,
um, yesterday I got my very first customer for this new product, which was originally called Quick Console, but is now
called Console Whisperer, which is, you know, kind of a funny name, but I, I, that's why I got it is that it kind of
made me laugh and I think will make people, you know, generate interest in other people. So yesterday I had my first
follow-up call with one of the very first people that checked it out. I showed him the use case, I offered him
the $50 lifetime deal and he said yes. And again, I'm not making all the right business choices here because, you know, maybe he said yes, partly because the price was so low because I initially told him, you know, I'm going to try to do QLab style pricing that's like $
3 a day or $300 lifetime. And so maybe he said yes because $50 is so much less than $300. So, you know, that's not the
best way to do things. But that's okay. I'm, I'm happy to kind of just get this off the ground, get its first customer.
Um, I have a lot of fun ideas for this product. It's immediately much more complicated than I expected now that I've had
to refactor to a client server architecture and I've had to learn how to, um, package and distribute desktop
applications. And I feel like I'm probably doing a lot of things wrong, but it is fun to be working on something,
something that I can actually use and that hopefully will get some of its own users in the future.