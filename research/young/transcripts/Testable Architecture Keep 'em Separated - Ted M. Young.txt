My name is Ted M. Young and that M is
really important because there's another
Ted Young who's also in tech who also
lives in the San Francisco Bay area
where I am now. So Ted M Young, that's
who I am. Um I am a Java trainer, coach,
live coder. I do lots of live coding on
stream. So you can get all the
information on the links up here. And um
I've been a software developer for for
well I'm old. Uh so so I've worked for
for companies like Google and Apple and
eBay. Uh and throughout my career
I don't know how I got test this term
test infected like testing is really
really important to me. Um I have to
test things and I want automated tests.
I want to tell me if I make a change
did I break anything. Right? There's
nothing more anxietyprovoking than you
make a change and you have no idea if
you've broken something. Looks okay to
me, right? Looks good to me. Uh,
meanwhile, you just injected a bug. And
so, for the longest time, I've always
looked for ways to think about how do we
make our systems and our code bases more
amendable to testing. So this
presentation uh actually comes from I
have a full course that's four days long
on how to do this with lots of hand
hands-on stuff. Uh so we'll see how good
a job I do in compressing it. So
why
there always something goes wrong with
with uh uh when you plug in. So test
feedback is really important, right?
Being able to make a change and either
have a test or modify a test, you do
test first and have uh the code then
then change to make sure the test
passes. Getting that fast feedback is
really important, right? If I run a test
and it takes less than a second, I'm
going to be running that pretty
frequently, which means the second I
make a mistake, I will find out.
Literally the second I make a mistake, I
will find out if it's a mistake or not,
right? I'll find out test will fail. The
longer it takes, the less likely you're
going to run it. Maybe I won't run it
today. Maybe I won't run it this week.
Maybe I'll wait to goes into continuous
integration. Who the heck knows? So fast
feedback is really important. And one of
the ways of doing that is is to figure
out what makes things slow, what makes
things difficult to do. So that's about
the testing part. The architecture,
well, what is architecture? Right? off
with a question that comes up. Um,
architecture in in this context is about
organization of code. So, organization
of code is what goes where and it's not
just which folders do I have, what do I
name them, how do I organize them. Um
but also what goes inside of of each
individual cost. And so uh the other
thing that we talk about when you talk
about architecture is uh what what I
call deployment or operational.
What are the artifacts? Are we doing
microser? Do we have monolith? Hopefully
it's modular. Where does where does that
go? Um where do we distribute it? And uh
often the terms about
these kinds of things are are confused.
So I'm here to tell you the original
meaning of layers is this. How do we
organize our code?
This stuff is tiers. They are not the
same thing. Tears are not layers. Tiers
are not layers. If you take one thing
out of this presentation, tiers are not
layers. Hopefully you'll take one. Get
it? So, we're going to focus on how code
gets organized because writing writing
tests can be hard because classes are
poorly organized and they often mix
logic, right? The logic is what business
cares about the rules. What do we want
it to do? When do we want it to do it?
Why is it doing it? Um, and IO, which in
a sense like business doesn't care
about. I don't care where you get that
stuff. Do you store it in a CSV file? Do
you store it in a database? We could
care less is make it work, make it fast.
And so classes tend to be poorly
organized with having too much state,
too many responsibilities,
methods that are too long. Um,
mixing logic and IO is problematic
because IO is not just a file or
network. It's anything relating to
infrastructure, hardware, and framework.
Uh, the whole course on the first part.
So we're going to focus on the second
part. So IO, I'm going to use this term
very generally. IO is anything that runs
outside of the current process you're
in. Right? So if you're in Java, you're
running on a JVM, anything that's
outside the JVM
is IO because in order to communicate
with that, you have to do IO.
And so that means hardware, right?
System clock, what time is it? What day
is it? That's IO. You're asking for
something that's outside your process.
random numbers, local files, remote
services over HTTP, etc. databases
whether they're in memory or not, right?
If you're using an in-memory database,
maybe using uh SQLite or good old H2, um
these are out of out of processes and
any other process that that might be
running. Uh frameworks are kind of
interesting. So frameworks like Spring
or maybe Caucus or others, they do a lot
of the other stuff that we see above
here behind the scenes sometimes,
I consider them IO. And so we want to
keep things separated.
So I came up with this hatching acronym.
No, it's not. It's terrible.
Uh which stands for separating concerns
of IO and nonio for testability.
does not exactly roll off the tongue.
And so that's why I call this testable
architecture.
And there are a bunch of patterns a
bunch of architectural patterns
that we can look at.
So who's heard of clean architecture?
Yeah, pretty popular. Hexogonal.
That's my favorite.
Onion.
Yeah, some of you.
Imperative shell functional core.
couple impressive
boundary controller entity
that yeah how many of you've been around
for 30 40 years you you know this one
and uh this one is called A-Frame from
from James Shore
all of these are the same thing except
for the details but the whole thing that
they want to do is say I want the
important business domain logic over
here which has no connection directly to
IO because that makes that easier to
test. And then I've got all the other
crap that we have to do that's to get
our stuff to work and integrate with
other systems.
All right, so let's look at some some
code.
Now, this code is probably something you
might find in like a a Java intro Java
intro course. So, we've got, hey, let's
display a little menu. You pick an item,
right? So we see there's a scatter there
on line uh 18. That's IO.
And what do we do? We we take the choice
and then we use a switch expression to
figure out and map that choice onto to a
number. We do some calculations and then
we display it also IO.
How do you test this?
Well, if you're in an intro job course,
you sit there and at the terminal and
you type one, okay, that looks good.
Two, that looks good. three. That looks
good.
Well, that's not any way to really test
stuff, right? We don't like manual
stuff. We want automated, repeatable
stuff. That's what computers are good
at. But this is really hard to test. Oh,
we can do it. Let me tell you, we can do
it. I've done it. Uh in the previous
presentation, uh Nate mentioned uh
characterization tests. The idea of what
does it do? Now, I wanted to pin it
down. Right or wrong, it is what it is.
How do I pin it down?
Well, one way is you hijack the system
out and system in. And I've left out
that code because it's
it is what it is. And so this is really
awkward. Like I'm I'm basically what I
always think about is this. I'm like
trying to turn on a light switch with a
10-ft pole. Oh, you can do it. It is not
fun. It is not easy. And it is very
prone to error.
So when you're testing mixed concerns,
anything that mixes concerns, right? The
important stuff, the stuff that the
business cares about
is this stuff and maybe a little bit
about this, but mostly about this,
especially if now, hey, well, we don't
charge sales tax on everything. Let me
tell you, if you've ever done and looked
into sales tax calculations and how that
works, there are companies that are
dedicated to just figuring that out. It
is not easy. let alone when you go
international, forget it. Let somebody
else handle that. And so if I make a
change and say, hey, if this is hot food
served with utensils blah blah blah,
then it gets calculated as as with sales
tax and put that decision logic in.
That's going to be really hard to test
using this mechanism. So what do we do?
We refactor out the calculations. We
separate the things. And to me, this is
it. This is what you do to code that is
hard to test. If you find code that has
lots of mixture of these concerns
and it's hard to test without doing lots
of mocking using mocking tools which I'm
on the record as saying I hate them.
They have their use but I hate them
because they lead people to do things
like not separate concerns. So if you
start out separating concerns you're
great. If not you can refactor. So we
want to refactor out those calculations
that those business rules whatever that
is we call that the main logic. So what
do we do? This is what we do. We split
it out into two pieces.
On the left we've got the IO stuff
dealing with system out and system in.
And then on the right that's the stuff
the business cares about and wants to
get right. And you as a developer want
to make sure that it's easy to test. So
now the test for the stuff on the left,
well I can still hijack stuff, make
sure, but then I only have to write one
test. I don't have to comprehensively
test this this code
indirectly. I can test it directly and
now it's trivial.
I say compute the receipt for choice
number one. Now it seems a little
awkward. What is one? Where does that
come from? Right? Well, you start
somewhere.
And so now and of course I'm also
checking like string output. file is
still a little bit of it's not quite
I/IO but it's a little bit dependent on
some kind of formatting. So maybe I have
to pull that out. And so
one of the things I do in in the course
is is we sit there and slowly piece by
piece refactor out is this calculation
logic, is this domain logic, is this
business logic, whatever you want to
call it, or is this IO? And I want to
split those apart.
And I keep splitting and keep splitting
them. And you may end up with a mess,
but at least it's a somewhat easier to
test mess, right? You may end up with
stuff all over the place.
The other advantage though in addition
to testing is now that code is reusable.
Hey, we're switching from command line
to a web-based API
over HTTP.
Cool.
All right, I write a controller in good
old spring and there we go. We take the
choice in through the API and then we
basically uh parse it in that string
into an int,
call the the method that we pulled out,
compute the receipt. Boom. We didn't
have to change our logic. We now have a
new way to interact with with that same
code. Now, it's probably unlikely that
you're going to do a lot of that, but
let me tell you, having this separation
and not putting your domain logic in
things like controllers and so on. The
first thing I do but I see that and I
see that a lot as a technical coach uh
is we pull that out so it's easier to
test.
It's like, oh, we don't want that is
with this API. We now want to use event
driven event over over Kafka. That's
more likely. Well, now what do you do?
If you separated it out, easy peasy.
So, we separated things out, but we need
a little bit more about organizing code.
I like hexogonal because I love
hexagons. Hexagons are the best.
Um, but
I don't use pure hexogonal. Hexogonal
basically says hello stuff and I want to
say a little more stuff. So let's go
through that.
So hexogonal architecture uh comes from
Alistister Coburn uh who's written on
things like use cases and agile and
things like that. Uh it's
you look at the original brand up it's
like a couple of pages. Um
it's also known as ports and adapters.
You may know know it as that. I still
like hexagonal because I like the shape.
So this is what he wrote in the original
write up for for hexagonal. And to me it
is really interesting.
And so I'm going to highlight a couple
of things.
So allow an application right to be
equally
driven by users programs and automated
test. In other words, the way a user
interacts with it and the way your test
interacts with that code should be
exactly the same. It shouldn't have some
if statement somewhere. Well, if it's a
test, do this. If it's a user, do this.
Same exact code used by anything,
right? Users, other systems, and tests.
They are all on a level playing field.
And then tested in isolation. I can test
that domain logic in isolation.
And I can also isolate other parts. I
can isolate the part that's doing the
transformation of this complex message
that I got from an external system into
the bytes and numbers and dates and
other kinds of things that I need to
call the actual domain logic.
So there's an inside and there's an
outside. That's the way hexogonal looks
at the world. And again, it's consistent
with all these other separation
concerns, architectures, imperative,
right? This is literally
imperative. uh uh core uh sorry
functional core imperative shell always
get those mixed up
right there's the inside the inside is
the important stuff from one point of
view which is what the heck is the
system for what is it doing how is it
doing it why is it doing it and then the
rest of the world is on the outside
how does it interact how does it
integrate how does it talk to other
other systems and so one of the thing I
like about the hexogal versus some of
the other diagramming right because if
you really you know squint they're all
just different ways of diagramming again
the same thing so I like hexogonal
because it has this left to right kind
of flow on the left side is is any kinds
of inputs these I call triggers or
sometimes uh uh we'll look at some other
terms and then there's outputs what
happens as a result right there's return
back to the original maybe maybe there's
a return maybe there's not um but
there's usually some kind of side effect
like we persist something somewhere or
notify somebody else, right? If I place
an order, put something in a shopping
cart, pay for it, well, stuff is going
to be sent to some warehouse, they know
what to ship, accounting with payments
and all all that kind of stuff. There's
a bunch of stuff that happens.
So, inputs and requests, outputs and
vents.
So what this looks like is right, hey,
there's some user because somebody's got
to trigger something. It might be a
user, it might be a robot, it might be
some cron job, who knows, right? They're
driving the application. They're pushing
it through whatever states it needs to
go through, right? Those inputs,
requests cause the application and
domain code to do something. As a result
of that something, they are driving
something else.
They're sending outputs. They're sending
events.
Now, driving and driven is the original
terminology that Coburn used. I don't
like it because it's very confusing
because they have very uh a lot of
letters in common. So, I prefer inbound
and outbound.
So, inbound is stuff that comes in or
triggers and then then you've got
outbound.
So as I mentioned Alistister in his
original writeup
it's very simple and I want one more
thing which is I want a strong domain.
the original hexagonal architecture
write up doesn't she says inside of this
this part I don't care right it's inside
I don't care how you organize it well
Alistister doesn't care I care I care a
lot and this is comes from domain driven
design I want my domain to be really
well thought out use the same
terminology that the business folks do
using all sorts of techniques that you
get from domain driven design to have a
solid model of our domain,
right? And so this domain has no
knowledge of IO, right? It's like this
pure platonic ideal of no connection to
the world, but it can do lots of
thinking and figuring stuff out
around that. We wrap a layer, the
application layer. This is what often is
coordinating things.
So, it also has no
concrete references to IO, but it at
least has the idea
that IO exists. Domain has no idea. It's
thinking about things like uh tickets
and concerts and things like that. It
has no idea that the world exists.
Application layer says, "Oh, well,
there's some things out there like
persistence
and I have to notify things like send an
email when you purchase something." So,
there's at least a concept, but there's
no like, are you using SMTP? Are you
using POP for email? Are you using text
messaging? Who the heck knows? I just
know you're using something. When I say
notep,
that's the hexagon. And so, inside
you've got the domain, which knows
nothing about the outside world. It
knows how to do its job. Application
layer does coordination.
And so, this is the boundary. This is
what we talk to. Well, how do we talk to
it? Well, we got to plug something into
it. And so these are what exogle
architecture calls adapters, hence the
name ports and adapters.
So a UI can plug in and it is the
interpreter interactor, right? All these
names for I got some form submission.
What do I do with it? How do I parse it?
What am I looking for? And then what do
I pass it on? Now that I've built and
validated and done all those kinds of
transformations, what do I call inside
the hexagon
might be an external message box? Same
thing. It has to translate differently,
different technology,
right? So cube messages, it has to
translate it, transform it, validate it,
do all that kind of stuff.
Now when we talk about testing we can
ignore or one point of view of testing
we can ignore those adapters. We say I
want to drive tests to test my hexagon
because it's a lot easier and faster and
the closer you are to testing the code
the more uh concise it is if it fails.
You don't get some big failure saying
something failed somewhere. You know
exactly where it failed.
So on the other side and this is this
left to right kind of asymmetry right on
the left side we have things that
trigger and send stuff in. On the right
side is is how the application uses
things like persistence to store a state
externally or send information outwards
through through notifiers and I want to
send a text message.
And so one of the important things here
is that the dependency is quite inward
right and they have to because the
domain cannot know IO not allowed
no can do so. So the dependencies must
flow inward
and then we have our system boundary and
this is where we can think of this is
sort of our deployable artifact
and no domain objects can live outside
of this.
Now this is a sequence diagram. I'm not
going to go through this. You can you
can go look at the slide later. But you
can see that what happens is at the top
we have the inputs and as it flows down
it communicates with different parts to
different ports and adapters and
services and then we get the thing back
out.
Right? So the dependencies point inwards
because we want the domain to be
completely isolated from the fact that
the outside world exists.
But we also want to be able to plug
things in for for testability.
So, I'm going to finish with looking at
um an application I use to manage uh
ensembles or mob programming groups.
And that's code is actually open source.
So, you're welcome to go look at it and
see how it's or organized and how the
tests work.
So, I've got my inbound adapter and I've
got a sang grid emailer which I actually
have to now replace because they're not
charging.
Um I've got a Zoomuler for scheduling
those those events. So these are the
different uh ports and adapters that I
have. And so let's look at the types of
tests. So for IO free tests, note that I
have not used the term unit and
integration test. Those terms are
terrible. Every time somebody says unit,
I say what do you mean what is a unit?
Right? And you can get into a debate for
that gets you nowhere. Not important.
What's important is it use IO or not. To
me, that's all that matters. So IO free
tests against the domain
straightforward. just drives that domain
logic directly.
Looks something like this. Really easy.
And that's kind of the thing. Yes, the
domain might be complex and you might
have some more things going on, but you
shouldn't see test doubles, mocks,
anything like that here.
Not at all. It don't exist at this level
because there's no need. You just
instantiate an object.
When you're testing out the application
layer, you still don't want to use IO
yet. So, you plug in a mock a test
double
and so now you can test at the app layer
tests are running fast but now you need
to substitute now you need to mention
this idea of I've got this thing that I
want to simulate but it's not really
there
and so this is this test actually uh
which one is this oh yeah so if the the
zoom was canceled then it makes sure to
that the delete got sent out and then we
have other tests that test the the
adapter directly
don't have a lot of those don't don't
need them most of the work and phase
that I need to test are you to call the
right thing at the right time
so other things you might use different
test doubles like a spy to figure out
hey did it send out that that message
and it looks like this
some lot more there's a lot of code
behind this so I'll refer you to to the
to the source code repository um but
again the idea here is Did it get
notified?
So, it's all trade-offs, right? Software
engineering is trade-offs. When we
increase testability by separating
things out, we lose simplicity. It's not
all in one big file.
I'm okay with that.
I think that's okay. Not everybody likes
it. And so, you'll get variations on,
well, we'll stuff a little bit more into
here or we'll put them into more
separate pieces. It's a continuum. So,
it's all a trade-off.
But I think if you use a testable
architecture, I don't care which one you
pick. I mean, I have my preference, but
pick whichever one you want. To me, the
important thing is if you want your code
to be easier to test, keep them
separated.
Thank you.